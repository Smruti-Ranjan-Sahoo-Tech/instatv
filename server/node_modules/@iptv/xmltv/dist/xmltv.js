function A(t) {
  t = t.replace(/[\s]/g, "");
  let e, n;
  const i = t.replace(/\D+/g, "");
  if (i.length <= 8) {
    if (i.length === 8) {
      const b = parseInt(i.slice(0, 4), 10), w = parseInt(i.slice(4, 6), 10) - 1 || 0, N = parseInt(i.slice(6, 8), 10) || 1;
      return new Date(Date.UTC(b, w, N));
    }
    if (i.length === 6) {
      const b = parseInt(i.slice(0, 4), 10), w = parseInt(i.slice(4, 6), 10) - 1 || 0;
      return new Date(Date.UTC(b, w));
    }
    if (i.length === 4)
      return new Date(i);
  }
  t.endsWith("Z") ? (e = t.slice(0, -1), n = null) : (e = t.slice(0, -5), n = t.slice(-5));
  const a = e.replace(/[-:Zz]/g, ""), s = parseInt(a.slice(0, 4), 10), r = parseInt(a.slice(4, 6), 10) - 1 || 0, o = parseInt(a.slice(6, 8), 10) || 1, c = parseInt(a.slice(8, 10), 10) || 0, p = parseInt(a.slice(10, 12), 10) || 0, C = parseInt(a.slice(12, 14), 10) || 0, y = new Date(Date.UTC(s, r, o, c, p, C));
  if (n) {
    const b = n.slice(0, 1), w = parseInt(n.slice(1, 3), 10), N = parseInt(n.slice(3, 5), 10), D = w * 60 + N;
    b === "+" ? y.setUTCMinutes(y.getUTCMinutes() - D) : b === "-" && y.setUTCMinutes(y.getUTCMinutes() + D);
  }
  return y;
}
function O(t) {
  const e = (c) => c < 10 ? `0${c}` : c.toString(), n = e(t.getUTCFullYear()), i = e(t.getUTCMonth() + 1), a = e(t.getUTCDate()), s = e(t.getUTCHours()), r = e(t.getUTCMinutes()), o = e(t.getUTCSeconds());
  return `${n}${i}${a}${s}${r}${o} +0000`;
}
function B(t) {
  const e = /* @__PURE__ */ new Map();
  for (const [n, i] of t.entries())
    e.set(i, n);
  return e;
}
const q = [
  "actor",
  "adapter",
  "aspect",
  "audio",
  "category",
  "channel",
  "colour",
  "commentator",
  "composer",
  "country",
  "credits",
  "date",
  "desc",
  "director",
  "display-name",
  "editor",
  "episode-num",
  "guest",
  "icon",
  "image",
  "keyword",
  "language",
  "last-chance",
  "length",
  "new",
  "orig-language",
  "premiere",
  "present",
  "presenter",
  "previously-shown",
  "producer",
  "programme",
  "quality",
  "rating",
  "review",
  "star-rating",
  "stereo",
  "sub-title",
  "subtitles",
  "title",
  "tv",
  "url",
  "value",
  "video",
  "writer"
], I = [
  "channel",
  "clumpidx",
  "date",
  "generator-info-name",
  "generator-info-url",
  "guest",
  "height",
  "id",
  "lang",
  "orient",
  "pdc-start",
  "reviewer",
  "role",
  "showview",
  "size",
  "source-data-url",
  "source-info-name",
  "source-info-url",
  "source",
  "src",
  "start",
  "stop",
  "system",
  "type",
  "units",
  "videoplus",
  "vps-start",
  "width"
], M = new Map([...q.map((t) => [t, t])]), E = new Map([
  ...I.map((t) => [t, t])
]), Y = B(M), P = B(E);
function m(t, e) {
  if (!q.includes(t))
    throw new Error(`Invalid tag: ${t}`);
  const n = M, i = Y;
  n && i && (n.set(t, e), i.set(e, t));
}
function T(t, e) {
  if (!I.includes(t))
    throw new Error(`Invalid attribute: ${t}`);
  const n = E, i = P;
  n && i && (n.set(t, e), i.set(e, t));
}
m("display-name", "displayName");
m("episode-num", "episodeNum");
m("last-chance", "lastChance");
m("orig-language", "origLanguage");
m("previously-shown", "previouslyShown");
m("star-rating", "starRating");
m("sub-title", "subTitle");
m("channel", "channels");
m("programme", "programmes");
T("generator-info-name", "generatorInfoName");
T("generator-info-url", "generatorInfoUrl");
T("pdc-start", "pdcStart");
T("vps-start", "vpsStart");
T("source-data-url", "sourceDataUrl");
T("source-info-name", "sourceInfoName");
T("source-info-url", "sourceInfoUrl");
function U(t, e = "tv", n = !1) {
  if (Array.isArray(t))
    return t.map((s) => U(s, e, !0));
  if (typeof t == "number")
    return t.toString();
  if (typeof t == "string")
    return t;
  if (t instanceof Date && e !== "date")
    return O(t);
  if (typeof t == "boolean" && e !== "new")
    return t ? "yes" : "no";
  const i = Y.get(e) || e, a = {
    tagName: i,
    attributes: {},
    children: []
  };
  for (let s in t) {
    const r = P.get(s) || s;
    if (t[s].tagName === "new") {
      t[i].children = [];
      continue;
    }
    if (I.indexOf(r) >= 0 && typeof t[s] != "object" || t[s] instanceof Date) {
      if (a.tagName === "credits" && s === "guest")
        continue;
      if (a.tagName === "programme" && s === "channel") {
        a.attributes[r] = t[s];
        continue;
      }
      if (a.tagName === "tv" && s === "date") {
        a.attributes[r] = O(t[s]);
        continue;
      }
      if (a.tagName === "programme" && s === "date") {
        a.children.push({
          tagName: r,
          attributes: {},
          children: [O(t[s])]
        });
        continue;
      }
      const o = typeof t[s];
      if (o === "number") {
        a.attributes[r] = t[s].toString();
        continue;
      }
      if (o === "boolean") {
        a.attributes[r] = t[s] ? "yes" : "no";
        continue;
      }
      if (o === "object" && !Array.isArray(t[s])) {
        if (t[s] instanceof Date) {
          t[s] = O(t[s]), a.attributes[r] = t[s];
          continue;
        }
        const c = Object.keys(t[s]).map((p) => {
          t[s][p] = t[s][p].toString();
        });
        a.attributes[r] = c;
        continue;
      }
      a.attributes[r] = t[s];
    } else {
      const o = U(t[s], s);
      if (Array.isArray(o))
        for (let c = 0, p = o.length; c < p; c++)
          a.children.push(o[c]);
      else {
        if (s !== "_value") {
          a.children.push({
            tagName: r,
            attributes: {},
            children: [o]
          });
          continue;
        }
        a.children.push(o);
      }
    }
  }
  return n ? a : [a];
}
function k(t) {
  let e = 0;
  const n = "<", i = ">", a = n.charCodeAt(0), s = i.charCodeAt(0), r = 45, o = 47, c = 33, p = 39, C = 34, y = 91, b = 93, w = 63, N = `\r
	>/= `, D = ["new", "icon", "previously-shown"];
  function $(l) {
    const f = [];
    for (; t[e]; )
      if (t.charCodeAt(e) == a) {
        if (t.charCodeAt(e + 1) === o) {
          const d = e + 2;
          if (e = t.indexOf(i, e), t.substring(d, e).indexOf(l) == -1) {
            const u = t.substring(0, e).split(`
`);
            throw new Error(
              `Unexpected close tag
Line: ` + (u.length - 1) + `
Column: ` + (u[u.length - 1].length + 1) + `
Char: ` + t[e]
            );
          }
          return e + 1 && (e += 1), f;
        } else if (t.charCodeAt(e + 1) === c) {
          if (t.charCodeAt(e + 2) == r) {
            for (; e !== -1 && !(t.charCodeAt(e) === s && t.charCodeAt(e - 1) == r && t.charCodeAt(e - 2) == r && e != -1); )
              e = t.indexOf(i, e + 1);
            e === -1 && (e = t.length);
          } else {
            const d = e + 1;
            e += 2;
            let g = !1;
            for (; (t.charCodeAt(e) !== s || g === !0) && t[e]; )
              t.charCodeAt(e) === y ? g = !0 : g === !0 && t.charCodeAt(e) === b && (g = !1), e++;
            f.push(t.substring(d, e));
          }
          e++;
          continue;
        }
        const h = L();
        if (f.push(h), h.tagName.charCodeAt(0) === w && h.children) {
          for (let d = 0, g = h.children.length; d < g; d++)
            f.push(h.children[d]);
          h.children = [];
        }
      } else {
        const h = Z().trim();
        h.length > 0 && f.push(h), e++;
      }
    return f;
  }
  function Z() {
    const l = e;
    return e = t.indexOf(n, e) - 1, e === -2 && (e = t.length), t.slice(l, e + 1);
  }
  function _() {
    const l = e;
    for (; N.indexOf(t[e]) === -1 && t[e]; )
      e++;
    return t.slice(l, e);
  }
  function L() {
    e++;
    const l = _(), f = {};
    let h = [];
    for (; t.charCodeAt(e) !== s && t[e]; ) {
      const d = t.charCodeAt(e);
      if (d > 64 && d < 91 || d > 96 && d < 123) {
        const g = _();
        let u = t.charCodeAt(e), v;
        for (; u && u !== p && u !== C && !(u > 64 && u < 91 || u > 96 && u < 123) && u !== s; )
          e++, u = t.charCodeAt(e);
        if (u === p || u === C) {
          if (v = R(), e === -1)
            return {
              tagName: l,
              attributes: f,
              children: h
            };
        } else
          v = null, e--;
        f[g] = v;
      }
      e++;
    }
    return t.charCodeAt(e - 1) !== o && D.indexOf(l) === -1 ? (e++, h = $(l)) : e++, l === "date" ? {
      tagName: l,
      attributes: f,
      children: h.map(
        (d) => O(A(d))
      )
    } : {
      tagName: l,
      attributes: f,
      children: h
    };
  }
  function R() {
    const l = t[e], f = e + 1;
    return e = t.indexOf(l, f), t.slice(f, e);
  }
  return $("");
}
const F = 63, H = [
  "credits",
  "date",
  "language",
  "orig-language",
  "length",
  "country",
  "previously-shown",
  "premiere",
  "last-chance",
  "new",
  "video",
  "audio",
  // Sub-elements of 'video'
  "present",
  "colour",
  "aspect",
  "quality",
  // Sub-elements of 'audio'
  "present",
  "stereo",
  //sub-elements of rating and star rating
  "value"
], Q = ["date", "value", "aspect", "present", "colour", "quality", "stereo"];
function X(t, e = { tagName: "tv", attributes: {}, children: [] }) {
  let n = {};
  if (!t.length)
    return n;
  if (t.length === 1 && typeof t[0] == "string" && (t[0] === "yes" || t[0] === "no"))
    return t[0] === "yes";
  if (t.length === 1 && typeof t[0] == "string" && typeof e != "string")
    return Object.keys(e.attributes).length ? {
      _value: t[0]
    } : t[0];
  for (let i = 0, a = t.length; i < a; i++) {
    let s = t[i];
    if (typeof e != "string" && e.tagName === "actor" && typeof s == "string" && (n._value = s), typeof s != "object" || s.tagName.charCodeAt(0) === F)
      continue;
    if (s.tagName === "new") {
      n[s.tagName] = !0;
      continue;
    }
    s.tagName === "tv" && (n = {});
    const r = M.get(s.tagName) || s.tagName;
    !n[r] && H.indexOf(s.tagName) === -1 && (n[r] = []);
    let o = X(s.children || [], s);
    if (Object.keys(s.attributes).length && !Array.isArray(o)) {
      s.attributes.size && (s.attributes.size = Number(s.attributes.size)), r === "programmes" ? (s.attributes.stop && (s.attributes.stop = A(s.attributes.stop)), s.attributes["pdc-start"] && (s.attributes["pdc-start"] = A(s.attributes["pdc-start"])), s.attributes["vps-start"] && (s.attributes["vps-start"] = A(s.attributes["vps-start"]))) : r === "icon" ? (s.attributes.width && (s.attributes.width = Number(s.attributes.width)), s.attributes.height && (s.attributes.height = Number(s.attributes.height))) : s.attributes.units ? o._value = Number(o._value) : s.attributes.guest && (s.attributes.guest = s.attributes.guest === "yes"), s.attributes.date && (s.attributes.date = A(s.attributes.date)), s.attributes.start && (s.attributes.start = A(s.attributes.start));
      const c = Object.keys(s.attributes).reduce(
        (p, C) => (p[E.get(C) || C] = s.attributes[C], p),
        {}
      );
      Object.assign(o, c);
    }
    if (r === "subtitles") {
      typeof o.language == "string" && (o.language = { _value: o.language }), n[r].push(o);
      continue;
    }
    if (r === "tv") {
      n = o;
      continue;
    }
    if (r === "date") {
      n[r] = A(o);
      continue;
    }
    if (typeof o == "string" && Q.indexOf(s.tagName) === -1 && (o = {
      _value: o
    }), Array.isArray(n[r])) {
      n[r].push(o);
      continue;
    }
    n[r] = o;
  }
  return n;
}
function z(t) {
  let e = "";
  function n(s) {
    if (s)
      for (var r = 0; r < s.length; r++)
        if (typeof s[r] == "string") {
          if (s[r].includes("!DOCTYPE")) {
            e += "<" + s[r].trim() + ">";
            continue;
          }
          e += s[r].trim();
        } else
          i(s[r]);
  }
  function i(s) {
    if (typeof s != "string") {
      e += "<" + s.tagName;
      for (const r in s.attributes)
        typeof s.attributes[r] == "string" && s.attributes[r].indexOf('"') === -1 ? e += " " + r + '="' + s.attributes[r].trim() + '"' : typeof s.attributes[r] == "boolean" ? e += " " + r + '="' + (s.attributes[r] ? "yes" : "no") + '"' : e += " " + r + "='" + s.attributes[r] + "'";
      if (["new", "icon", "previously-shown"].indexOf(s.tagName) >= 0) {
        e += "/>";
        return;
      }
      if (s.tagName === "?xml") {
        e += "?>";
        return;
      }
      if (e += ">", typeof s.children == "boolean") {
        e += s.children ? "yes" : "no";
        return;
      }
      n(s.children), e += "</" + s.tagName + ">";
    }
  }
  n(t);
  let a = "";
  return e.indexOf("?xml") === -1 && (a += '<?xml version="1.0" encoding="UTF-8"?>'), e.indexOf("!DOCTYPE") === -1 && (a += '<!DOCTYPE tv SYSTEM "xmltv.dtd">'), a + e;
}
function J(t, e = { asDom: !1 }) {
  const n = k(t);
  return e.asDom ? n : X(n);
}
function K(t, e = { fromDom: !1 }) {
  if (e.fromDom) {
    if (typeof t == "object" && !Array.isArray(t))
      throw new Error("Cannot write XMLTV from a DOM object that has been converted to an object");
    return z(t);
  }
  const n = U(t);
  return z(n);
}
export {
  T as addAttributeTranslation,
  m as addTagTranslation,
  U as objectToDom,
  J as parseXmltv,
  k as parser,
  K as writeXmltv,
  z as writer
};
